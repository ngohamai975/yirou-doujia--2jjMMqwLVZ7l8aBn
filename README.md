# 1. 引言

复习上一篇文章[《最小二乘问题详解1：线性最小二乘》](https://github.com)中的知识，对于一个线性问题模型：

f(x;θ)=Aθf(x;θ)=Aθ

那么线性最小二乘问题可以表达为求一组待定值θθ，使得残差的平方和最小：

minθ∥Aθ−b∥2minθ‖Aθ−b‖2

本质上是求解超定线性方程组：

Aθ=bAθ=b

具体的线性最小二乘解是：

θ∗=(ATA)−1ATb(1)(1)θ∗=(ATA)−1ATb

# 2. 求解

## 2.1 问题

虽然线性最小二乘解已经给出，但是并不意味着在实际的数值计算中就能按照式(1)来进行求解。一个典型的问题就是求逆矩阵：在工程实践和数值计算中，直接求解逆矩阵通常是一个性能消耗大且可能不精确的操作，应该尽量避免。举例来说，我们按照大学本科《线性代数》课程中的方法写程序来求解一个逆矩阵，假设使用伴随矩阵法：

A−1=1det(A)⋅adj(A)A−1=1det(A)⋅adj(A)

其中：

* det(A)det(A) 是矩阵 AA 的行列式。
* adj(A)adj(A) 是 AA 的伴随矩阵。

为了求解伴随矩阵 adj(A)adj(A)：

1. 求代数余子式 (Cofactor)：对于矩阵 AA 中的每一个元素 aijaij，计算其代数余子式 CijCij。

   * 代数余子式 Cij=(−1)i+j⋅MijCij=(−1)i+j⋅Mij
   * MijMij 是删去 AA 的第 ii 行和第 jj 列后得到的子矩阵的行列式（称为余子式）。
2. 构造余子式矩阵：将所有代数余子式 CijCij 按照原来的位置排列，形成一个新矩阵 CC（称为余子式矩阵）。
3. 转置：将余子式矩阵 CC 进行转置，得到的矩阵就是伴随矩阵 adj(A)adj(A)。

   adj(A)=CTadj(A)=CT
4. 代入公式：将 det(A)det(A) 和 adj(A)adj(A) 代入公式 A−1=1det(A)⋅adj(A)A−1=1det(A)⋅adj(A) 即可。

这里我们大概能估算，使用伴随矩阵法求逆矩阵的理论复杂度是O(n!)O(n!)，这是一个阶乘级的增长，算法效率非常低。《线性代数》中介绍的另外一种算法高斯消元法也只能达到O(n3)O(n3)，呈指数级增加。其实效率只是一方面的问题，使用计算机求解的另外一个问题是舍入误差累积：在计算机中，浮点数运算存在固有的舍入误差；求逆过程涉及大量的除法和减法运算，这些误差会在计算过程中不断累积和传播。总而言之，使用通解求解逆矩阵，可能存在不精确且性能消耗大的问题。

## 2.2 QR分解

那么不使用逆矩阵怎么办呢？我们需要注意的是，最小二乘问题的本质是求解，而不是求逆矩阵，因此关键是要求解**正规方程**：

ATAθ=ATbATAθ=ATb

对矩阵AA作QR分解：

A=Q1RA=Q1R

其中:

* Q1∈Rm×nQ1∈Rm×n 列正交，满足QT1Q1=InQ1TQ1=In；
* R∈Rn×nR∈Rn×n是上三角矩阵，如果AA列满秩，则RR的对角元均非零，可逆。

那么把A=Q1RA=Q1R代入正规方程，得到：

(Q1R)T(Q1R)x=(Q1R)Tb(Q1R)T(Q1R)x=(Q1R)Tb

左边整理，因为QT1Q1=InQ1TQ1=In：

RTQT1Q1Rx=RTRxRTQ1TQ1Rx=RTRx

右边为

RTQT1bRTQ1Tb

因此正规方程等价于

RTRx=RT(QT1b)RTRx=RT(Q1Tb)

若RR可逆（即AA满秩，rank(A)=nrank⁡(A)=n），则RTRT也可逆。左右两边左乘(RT)−1(RT)−1，得到：

Rx=QT1b.Rx=Q1Tb.

令c=Q⊤1bc=Q1⊤b（这是一个长度为nn的向量），于是我们得到一个简单的**上三角线性系统**：

Rx=c,c=QT1bRx=c,c=Q1Tb

这就是QR方法把正规方程化简得到的核心结果：只需解上三角方程Rx=QT1bRx=Q1Tb。

以上只是对AA列满秩的情况做了推导，如果AA列满秩，那么QR分解可以表示为x=R−1Q⊤1bx=R−1Q1⊤b；如果AA列不满秩（RR奇异），需要使用列主元QR方法对RTRx=RT(QT1b)RTRx=RT(Q1Tb)进行求解，或者干脆使用下面要介绍的SVD分解（奇异值分解）法。

## 2.3 SVD分解

另外一种求解的方法是SVD分解。对任意矩阵AA，存在奇异值分解：

A=UΣVTA=UΣVT

其中:

* U∈Rm×mU∈Rm×m为正交（列为左奇异向量），
* V∈Rn×nV∈Rn×n为正交（列为右奇异向量），
* Σ∈Rm×nΣ∈Rm×n为“对角块”矩阵，通常写成

  Σ=[Σr000]Σ=[Σr000]

  其中Σr=diag(σ1,…,σr)Σr=diag⁡(σ1,…,σr)，(σ1≥σ2≥⋯≥σr>0)(σ1≥σ2≥⋯≥σr>0)，r=rank(A)r=rank⁡(A)。

将SVD代入正规方程，先计算A⊤AA⊤A：

ATA=(UΣVT)T(UΣVT)=VΣTUTUΣVT=V(ΣTΣ)VT.ATA=(UΣVT)T(UΣVT)=VΣTUTUΣVT=V(ΣTΣ)VT.

注意UTU=IUTU=I。而ΣTΣΣTΣ是n×nn×n的对角块矩阵，其非零对角元就是σ2i(i=1..r)σi2(i=1..r)，其余为零。

同样的，计算ATbATb：

ATb=VΣTUTb.ATb=VΣTUTb.

于是正规方程变为：

V(ΣTΣ)VTx=VΣTUTb.V(ΣTΣ)VTx=VΣTUTb.

两边左乘VTVT，因为VV正交，VTV=IVTV=I，得到：

(ΣTΣ)(VTx)=ΣT(UTb)(ΣTΣ)(VTx)=ΣT(UTb)

把y=VTxy=VTx与c=UTbc=UTb代入，得到更简单的对角方程：

(ΣTΣ)y=ΣTc(ΣTΣ)y=ΣTc

接下来按奇异值分块展开对角方程，先写出ΣΣ相关的形状：

Σ=[Σr000],Σ⊤Σ=[Σ2r000]Σ=[Σr000],Σ⊤Σ=[Σr2000]

对yy和cc也做相应分块：

y=[y1 y2],c=[c1 c2]y=[y1 y2],c=[c1 c2]

其中y1,c1∈Rry1,c1∈Rr对应非零奇异值，y2,c2y2,c2对应奇异值为0的部分（维度 n−rn−r）,代入得到分块方程:

[Σ2r000][y1y2]=[Σr000][c1c2][Σr2000][y1y2]=[Σr000][c1c2]

即等价于两组方程：

Σ2ry1=Σrc1,0=0⋅c2 (无约束／自由分量)Σr2y1=Σrc1,0=0⋅c2 (无约束／自由分量)

由于ΣrΣr为对角且可逆，第一式等价于

Σry1=c1⟹y1=Σ−1rc1.Σry1=c1⟹y1=Σr−1c1.

而y2y2（对应零奇异值的分量）在正规方程中不受约束——这反映了在列秩不足时普通最小二乘解不是唯一的（可以在零空间方向任意加解）。为得到**最小范数解**（惯常的选择），取 y2=0y2=0。

最后回到xx的求解，对于yy有：

y=[Σ−1rc10]y=[Σr−1c10]

将c1c1与c=U⊤bc=U⊤b关系代回：

y=[Σ−1r000]UTby=[Σr−1000]UTb

由于y=VTxy=VTx，于是：

x=Vy=V[Σ−1r000]UTbx=Vy=V[Σr−1000]UTb

定义Σ+Σ+为将非零奇异值取倒数后转置得到的伪逆矩阵（对角块为Σ−1rΣr−1，其余为0)，则

x+=VΣ+UTbx+=VΣ+UTb

这就是 **最小二乘的 Moore–Penrose 伪逆解**：

* 若AA列满秩，则为唯一最小二乘解，由于那么Σ+=Σ−1Σ+=Σ−1，SVD求解公式退化为常见的x=VΣ−1UTbx=VΣ−1UTb
* 若秩亏，它给出 **在所有最小二乘解中范数最小的那个**（minimum-norm solution）。

## 2.4 比较

从以上论述可以看到，SVD分解稳定且能处理秩亏的情况，但比QR分解慢，复杂度高，通常O(mn2)O(mn2)；QR分解在列满秩、条件数不是太差时更快；若需要判定秩或求最小范数解，SVD是首选。

# 3. 补充

在最后补充一些基础知识，也是笔者很感兴趣的一点，那就是为什么一个矩阵A可以进行QR分解或者SVD分解呢？

## 3.1 QR分解

QR分解其实非常好理解，它的本质其实就是大学本科《线性代数》课程中提到的**施密特（Gram–Schmidt）正交化**。我们先复习一下施密特正交化相关的知识。

设有一组线性无关向量

a1,a2,…,an∈Rma1,a2,…,an∈Rm

我们想把它们变成一组正交（再归一化后变成标准正交）的向量q1,q2,…,qnq1,q2,…,qn。具体步骤如下：

1. 取第一个向量，归一化：

   q1=a1|a1|q1=a1|a1|
2. 对第 2 个向量，先减去在q1q1上的投影：

   ~q2=a2−(qT1a2)q1q~2=a2−(q1Ta2)q1

   然后归一化：

   q2=~q2|~q2|q2=q~2|q~2|
3. 对第 3 个向量，减去它在前两个正交向量上的投影：

   ~q3=a3−(qT1a3)q1−(qT2a3)q2q~3=a3−(q1Ta3)q1−(q2Ta3)q2

   然后归一化：

   q3=~q3|~q3|q3=q~3|q~3|
4. 一般地，对第jj个向量：

   ~qj=aj−j−1∑i=1(qTiaj)qi,qj=~qj|~qj|q~j=aj−∑i=1j−1(qiTaj)qi,qj=q~j|q~j|

这样得到的qiqi就是**标准正交基**，且每个qjqj只用到了前j−1j−1个。

现在把矩阵AA看成由列向量组成：

A=[a1,a2,…,an]∈Rm×n.A=[a1,a2,…,an]∈Rm×n.

把施密特正交化写成矩阵形式，我们得到一组正交向量：

Q1=[q1,q2,…,qn]∈Rm×n,QT1Q1=In.Q1=[q1,q2,…,qn]∈Rm×n,Q1TQ1=In.

同时，原向量可以写成：

aj=j∑i=1rijqiaj=∑i=1jrijqi

其中：

rij=qTiajrij=qiTaj

把这些关系拼成矩阵形式：

A=Q1RA=Q1R

其中：

* R=(rij)R=(rij)是n×nn×n上三角矩阵，因为第jj列只用到前jj个qiqi。
* Q1Q1的列正交，所以QT1Q1=IQ1TQ1=I。

## 3.2 SVD分解

SVD分解其实也非常有意思，同样也可以顺着《线性代数》中基础知识来进行推导。首先复习一下特征值和特征向量。对于一个方阵 A∈Rn×nA∈Rn×n，如果存在一个非零向量 v∈Rnv∈Rn 和一个实数 λλ，使得：

Av=λvAv=λv

那么：

* λλ 称为 **特征值（eigenvalue）**
* vv 称为对应于 λλ 的 **特征向量（eigenvector）**

接下来复习一下什么叫做对角化。如果一个n×nn×n矩阵AA可以写成：

A=PDP−1A=PDP−1

其中：

* DD 是一个**对角矩阵**（只有对角线上有元素）
* PP 是一个可逆矩阵

我们就说 AA 是 **可对角化的**。

而且通常：

* DD 的对角元素是 AA 的特征值：D=diag(λ1,…,λn)D=diag⁡(λ1,…,λn)
* PP 的列是对应的特征向量

即：

P=[v1 v2 ⋯ vn],D=⎡⎢
⎢⎣λ1⋱λn⎤⎥
⎥⎦P=[v1 v2 ⋯ vn],D=[λ1⋱λn]

对角化非常重要，因为对角矩阵计算非常简单，比如计算DkDk只需把对角元各自取kk次方即可。对角化的本质就是**把复杂的线性变换，变成旋转 → 拉伸 → 逆旋转的过程**。注意，不是所有矩阵都能对角化，只有当矩阵有nn个线性无关的特征向量时，才能对角化。但是，所有对称矩阵（如 ATAATA）都可以对角化，而且可以使用正交矩阵对角化。

也就是说，存在正交矩阵VV，使得：

ATA=VΛVT,Λ=diag(λ1,…,λn)ATA=VΛVT,Λ=diag⁡(λ1,…,λn)

然后根据这个对角化公式，构造UU和ΣΣ，最终得到SVD：

A=UΣV⊤A=UΣV⊤

这里具体构造UU和ΣΣ的过程还是有点繁琐的，这里就不进一步推导了，免得离题太远。

本博客参考[westworld加速](https://westworldjs.com)。转载请注明出处！
